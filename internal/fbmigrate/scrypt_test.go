package fbmigrate

import (
	"crypto/aes"
	"crypto/cipher"
	"encoding/base64"
	"testing"

	"github.com/allyourbase/ayb/internal/testutil"
	"golang.org/x/crypto/scrypt"
)

func TestVerifyFirebaseScrypt(t *testing.T) {
	t.Parallel()
	t.Run("round trip", func(t *testing.T) {
		t.Parallel()
		password := "testpassword123"
		salt := []byte("testsalt")
		signerKey := make([]byte, 32)
		for i := range signerKey {
			signerKey[i] = byte(i)
		}
		saltSeparator := []byte{0x07}

		// Use small values for testing speed.
		rounds := 1
		memCost := 1 // N = 2^1 = 2

		// Generate expected hash by running the algorithm forward.
		expectedHash := computeFirebaseScryptHash(t, password, salt, signerKey, saltSeparator, rounds, memCost)

		ok, err := VerifyFirebaseScrypt(password, salt, expectedHash, signerKey, saltSeparator, rounds, memCost)
		testutil.NoError(t, err)
		testutil.True(t, ok, "correct password should verify")

		ok, err = VerifyFirebaseScrypt("wrongpassword", salt, expectedHash, signerKey, saltSeparator, rounds, memCost)
		testutil.NoError(t, err)
		testutil.True(t, !ok, "wrong password should not verify")
	})

	t.Run("different salts produce different results", func(t *testing.T) {
		t.Parallel()
		password := "password"
		signerKey := make([]byte, 32)
		for i := range signerKey {
			signerKey[i] = byte(i + 10)
		}
		saltSep := []byte{0x01}
		rounds := 1
		memCost := 1

		hash1 := computeFirebaseScryptHash(t, password, []byte("salt1"), signerKey, saltSep, rounds, memCost)
		hash2 := computeFirebaseScryptHash(t, password, []byte("salt2"), signerKey, saltSep, rounds, memCost)

		testutil.True(t, string(hash1) != string(hash2), "different salts should produce different hashes")
	})
}

// computeFirebaseScryptHash runs the Firebase scrypt algorithm forward to produce a hash.
func computeFirebaseScryptHash(t *testing.T, password string, salt, signerKey, saltSeparator []byte, rounds, memCost int) []byte {
	t.Helper()

	n := 1 << memCost
	fullSalt := make([]byte, len(salt)+len(saltSeparator))
	copy(fullSalt, salt)
	copy(fullSalt[len(salt):], saltSeparator)

	derivedKey, err := scrypt.Key([]byte(password), fullSalt, n, rounds, 1, 32)
	if err != nil {
		t.Fatalf("scrypt key: %v", err)
	}

	block, err := aes.NewCipher(derivedKey)
	if err != nil {
		t.Fatalf("aes cipher: %v", err)
	}

	iv := make([]byte, aes.BlockSize)
	stream := cipher.NewCTR(block, iv)
	encrypted := make([]byte, len(signerKey))
	stream.XORKeyStream(encrypted, signerKey)

	return encrypted
}

func TestVerifyFirebaseScryptExternalVector(t *testing.T) {
	// External test vector from https://github.com/JaakkoL/firebase-scrypt-python
	// These are real Firebase export values, NOT generated by our own code.
	t.Parallel()

	signerKey, err := base64.StdEncoding.DecodeString("jxspr8Ki0RYycVU8zykbdLGjFQ3McFUH0uiiTvC8pVMXAn210wjLNmdZJzxUECKbm0QsEmYUSDzZvpjeJ9WmXA==")
	testutil.NoError(t, err)
	saltSep, err := base64.StdEncoding.DecodeString("Bw==")
	testutil.NoError(t, err)
	salt, err := base64.StdEncoding.DecodeString("42xEC+ixf3L2lw==")
	testutil.NoError(t, err)
	passwordHash, err := base64.StdEncoding.DecodeString("lSrfV15cpx95/sZS2W9c9Kp6i/LVgQNDNC/qzrCnh1SAyZvqmZqAjTdn3aoItz+VHjoZilo78198JAdRuid5lQ==")
	testutil.NoError(t, err)

	rounds := 8
	memCost := 14

	ok, err := VerifyFirebaseScrypt("user1password", salt, passwordHash, signerKey, saltSep, rounds, memCost)
	testutil.NoError(t, err)
	testutil.True(t, ok, "known Firebase export should verify with correct password")

	ok, err = VerifyFirebaseScrypt("wrongpassword", salt, passwordHash, signerKey, saltSep, rounds, memCost)
	testutil.NoError(t, err)
	testutil.True(t, !ok, "known Firebase export should reject wrong password")
}

func TestParseFirebaseScryptHash(t *testing.T) {
	t.Parallel()
	t.Run("valid hash", func(t *testing.T) {
		t.Parallel()
		signerKeyB64 := base64.StdEncoding.EncodeToString([]byte("signerkey12345678901234567890AB"))
		saltSepB64 := base64.StdEncoding.EncodeToString([]byte("sep"))
		saltB64 := base64.StdEncoding.EncodeToString([]byte("salt"))
		pwHashB64 := base64.StdEncoding.EncodeToString([]byte("passwordhash"))

		encoded := "$firebase-scrypt$" + signerKeyB64 + "$" + saltSepB64 + "$" + saltB64 + "$8$14$" + pwHashB64

		signerKey, saltSep, salt, passwordHash, rounds, memCost, err := ParseFirebaseScryptHash(encoded)
		testutil.NoError(t, err)
		testutil.Equal(t, "signerkey12345678901234567890AB", string(signerKey))
		testutil.Equal(t, "sep", string(saltSep))
		testutil.Equal(t, "salt", string(salt))
		testutil.Equal(t, "passwordhash", string(passwordHash))
		testutil.Equal(t, 8, rounds)
		testutil.Equal(t, 14, memCost)
	})

	t.Run("not a firebase-scrypt hash", func(t *testing.T) {
		t.Parallel()
		_, _, _, _, _, _, err := ParseFirebaseScryptHash("$argon2id$v=19$m=65536")
		testutil.ErrorContains(t, err, "not a firebase-scrypt hash")
	})

	t.Run("wrong number of parts", func(t *testing.T) {
		t.Parallel()
		_, _, _, _, _, _, err := ParseFirebaseScryptHash("$firebase-scrypt$a$b$c")
		testutil.ErrorContains(t, err, "expected 6 parts")
	})

	t.Run("invalid base64 signer key", func(t *testing.T) {
		t.Parallel()
		_, _, _, _, _, _, err := ParseFirebaseScryptHash("$firebase-scrypt$!!!$YQ==$YQ==$8$14$YQ==")
		testutil.ErrorContains(t, err, "decoding signer key")
	})

	t.Run("invalid rounds", func(t *testing.T) {
		t.Parallel()
		b64 := base64.StdEncoding.EncodeToString([]byte("x"))
		encoded := "$firebase-scrypt$" + b64 + "$" + b64 + "$" + b64 + "$abc$14$" + b64
		_, _, _, _, _, _, err := ParseFirebaseScryptHash(encoded)
		testutil.ErrorContains(t, err, "parsing rounds")
	})

	t.Run("invalid memCost", func(t *testing.T) {
		t.Parallel()
		b64 := base64.StdEncoding.EncodeToString([]byte("x"))
		encoded := "$firebase-scrypt$" + b64 + "$" + b64 + "$" + b64 + "$8$abc$" + b64
		_, _, _, _, _, _, err := ParseFirebaseScryptHash(encoded)
		testutil.ErrorContains(t, err, "parsing memCost")
	})

	t.Run("invalid password hash base64", func(t *testing.T) {
		t.Parallel()
		b64 := base64.StdEncoding.EncodeToString([]byte("x"))
		encoded := "$firebase-scrypt$" + b64 + "$" + b64 + "$" + b64 + "$8$14$!!!"
		_, _, _, _, _, _, err := ParseFirebaseScryptHash(encoded)
		testutil.ErrorContains(t, err, "decoding password hash")
	})
}

func TestParseAndVerifyRoundTrip(t *testing.T) {
	// Encode → Parse → Verify full round trip.
	t.Parallel()

	password := "myPassword"
	salt := []byte("randomsalt")
	signerKey := make([]byte, 32)
	for i := range signerKey {
		signerKey[i] = byte(i * 3)
	}
	saltSep := []byte{0x07}
	rounds := 1
	memCost := 1

	// Compute the password hash.
	expectedHash := computeFirebaseScryptHash(t, password, salt, signerKey, saltSep, rounds, memCost)

	// Encode in AYB storage format (includes the password hash).
	config := &FirebaseHashConfig{
		Base64SignerKey:     base64.StdEncoding.EncodeToString(signerKey),
		Base64SaltSeparator: base64.StdEncoding.EncodeToString(saltSep),
		Rounds:              rounds,
		MemCost:             memCost,
	}
	saltB64 := base64.StdEncoding.EncodeToString(salt)
	pwHashB64 := base64.StdEncoding.EncodeToString(expectedHash)

	encoded := EncodeFirebaseScryptHash(pwHashB64, saltB64, config)
	testutil.Contains(t, encoded, "$firebase-scrypt$")

	// Parse it back.
	parsedSignerKey, parsedSaltSep, parsedSalt, parsedPwHash, parsedRounds, parsedMemCost, err := ParseFirebaseScryptHash(encoded)
	testutil.NoError(t, err)
	testutil.Equal(t, rounds, parsedRounds)
	testutil.Equal(t, memCost, parsedMemCost)

	// Verify with correct password.
	ok, err := VerifyFirebaseScrypt(password, parsedSalt, parsedPwHash, parsedSignerKey, parsedSaltSep, parsedRounds, parsedMemCost)
	testutil.NoError(t, err)
	testutil.True(t, ok, "round-trip should verify correct password")

	// Verify with wrong password.
	ok, err = VerifyFirebaseScrypt("wrongpassword", parsedSalt, parsedPwHash, parsedSignerKey, parsedSaltSep, parsedRounds, parsedMemCost)
	testutil.NoError(t, err)
	testutil.True(t, !ok, "round-trip should reject wrong password")
}
