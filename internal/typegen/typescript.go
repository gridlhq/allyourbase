package typegen

import (
	"fmt"
	"sort"
	"strings"
	"unicode"

	"github.com/allyourbase/ayb/internal/schema"
)

// TypeScript generates TypeScript interface declarations from a schema cache.
// The output is a self-contained .d.ts file with no external dependencies.
// System tables (prefixed _ayb_) are excluded.
func TypeScript(sc *schema.SchemaCache) string {
	var b strings.Builder
	b.WriteString("// Auto-generated by ayb types typescript â€” DO NOT EDIT\n\n")

	// Collect and sort table keys for deterministic output.
	keys := make([]string, 0, len(sc.Tables))
	for k := range sc.Tables {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	// Collect enums across all tables (deduplicated by name).
	enumsSeen := map[string][]string{}
	for _, k := range keys {
		t := sc.Tables[k]
		if isSystemTable(t.Name) {
			continue
		}
		for _, col := range t.Columns {
			if col.IsEnum && len(col.EnumValues) > 0 {
				enumName := pascalCase(col.TypeName)
				if _, ok := enumsSeen[enumName]; !ok {
					enumsSeen[enumName] = col.EnumValues
				}
			}
		}
	}

	// Emit enum types first (sorted for determinism).
	enumNames := make([]string, 0, len(enumsSeen))
	for name := range enumsSeen {
		enumNames = append(enumNames, name)
	}
	sort.Strings(enumNames)
	for _, name := range enumNames {
		values := enumsSeen[name]
		quoted := make([]string, len(values))
		for i, v := range values {
			quoted[i] = fmt.Sprintf("%q", v)
		}
		fmt.Fprintf(&b, "export type %s = %s;\n\n", name, strings.Join(quoted, " | "))
	}

	// Emit interfaces for each table.
	for _, k := range keys {
		t := sc.Tables[k]
		if isSystemTable(t.Name) {
			continue
		}
		writeTableInterface(&b, t)
	}

	return b.String()
}

func writeTableInterface(b *strings.Builder, t *schema.Table) {
	name := pascalCase(t.Name)

	if t.Comment != "" {
		fmt.Fprintf(b, "/** %s */\n", t.Comment)
	}
	fmt.Fprintf(b, "export interface %s {\n", name)
	for _, col := range t.Columns {
		tsType := jsonTypeToTS(col)
		if col.IsNullable {
			tsType += " | null"
		}
		if col.Comment != "" {
			fmt.Fprintf(b, "  /** %s */\n", col.Comment)
		}
		fmt.Fprintf(b, "  %s: %s;\n", col.Name, tsType)
	}
	fmt.Fprintf(b, "}\n\n")

	// Create type: omit PK columns and columns with defaults.
	omitFields := omitForCreate(t)
	if len(omitFields) > 0 {
		quoted := make([]string, len(omitFields))
		for i, f := range omitFields {
			quoted[i] = fmt.Sprintf("%q", f)
		}
		fmt.Fprintf(b, "export type %sCreate = Omit<%s, %s>;\n\n", name, name, strings.Join(quoted, " | "))
	} else {
		fmt.Fprintf(b, "export type %sCreate = %s;\n\n", name, name)
	}

	// Update type: partial of Create.
	fmt.Fprintf(b, "export type %sUpdate = Partial<%sCreate>;\n\n", name, name)
}

// omitForCreate returns column names that should be omitted from the Create type:
// primary key columns and columns with default expressions.
func omitForCreate(t *schema.Table) []string {
	var omit []string
	for _, col := range t.Columns {
		if col.IsPrimaryKey || col.DefaultExpr != "" {
			omit = append(omit, col.Name)
		}
	}
	return omit
}

// jsonTypeToTS maps a column's JSONType to a TypeScript type.
func jsonTypeToTS(col *schema.Column) string {
	// Enums with known values get a union type reference.
	if col.IsEnum && len(col.EnumValues) > 0 {
		return pascalCase(col.TypeName)
	}
	switch col.JSONType {
	case "integer", "number":
		return "number"
	case "boolean":
		return "boolean"
	case "object":
		return "Record<string, unknown>"
	case "array":
		return "unknown[]"
	default:
		return "string"
	}
}

// pascalCase converts a snake_case name to PascalCase.
func pascalCase(s string) string {
	var b strings.Builder
	upper := true
	for _, r := range s {
		if r == '_' || r == '-' || r == ' ' {
			upper = true
			continue
		}
		if upper {
			b.WriteRune(unicode.ToUpper(r))
			upper = false
		} else {
			b.WriteRune(r)
		}
	}
	return b.String()
}

func isSystemTable(name string) bool {
	return strings.HasPrefix(name, "_ayb_")
}
