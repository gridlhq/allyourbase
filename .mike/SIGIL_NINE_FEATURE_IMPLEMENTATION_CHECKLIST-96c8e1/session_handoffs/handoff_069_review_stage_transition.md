# Handoff 069 — Stage 4 Checklist Review & Correction

## What I did

### 1. Reviewed Stage 4 checklist generated by previous session

Read the full Stage 4 checklist, the feature requirements source (`_dev/AYB_FEATURE_CHECKLIST_from_SIJLE.md`), project proposal, and all relevant existing code:
- `internal/realtime/handler.go` — `canSeeRecord` implementation
- `internal/realtime/hub.go` — event broadcast
- `internal/realtime/visibility_test.go` — existing visibility tests
- `internal/auth/rls.go` — `SetRLSContext` (switches to `ayb_authenticated` role, sets session vars)
- `internal/schema/schema.go` — `Table.Kind` tracks `"materialized_view"` for matviews
- `internal/schema/introspect.go` — introspects `relkind='m'` for matviews
- `internal/server/rls_handler.go` — admin RLS policy CRUD

### 2. Found and corrected critical misconception about joined-table RLS

The previous checklist described `canSeeRecord` as doing a "simplified single-table check" and proposed "hardening" it to evaluate join-based policies. This is **incorrect**.

**Root cause of the misconception:** The feature checklist (`_dev/AYB_FEATURE_CHECKLIST_from_SIJLE.md`) says "The SSE system needs to evaluate the full RLS policy, not a simplified single-table check." This reads as if the code skips RLS, but it doesn't.

**What the code actually does:** `canSeeRecord` runs `SELECT 1 FROM "schema"."table" WHERE "pk" = $val` inside a transaction where `SetRLSContext` has already:
1. Switched to the `ayb_authenticated` role via `SET LOCAL ROLE`
2. Set `ayb.user_id` and `ayb.user_email` session vars

Since RLS is enforced by Postgres at the database level, this SELECT automatically evaluates ALL RLS policies on the table — including join-based policies like `USING (EXISTS (SELECT 1 FROM memberships WHERE ...))`. The query returns 0 rows if the user fails the RLS policy, regardless of how complex the policy is.

**Conclusion:** No code change is needed. Stage 4 RLS scope is reduced to: write integration tests proving join-based policies work, and document delete-event semantics.

### 3. Researched Postgres materialized view refresh patterns

Confirmed key requirements via Postgres docs:
- `REFRESH MATERIALIZED VIEW CONCURRENTLY` requires a UNIQUE index on the matview that covers all rows (no WHERE clause, no expression index)
- Standard refresh takes ACCESS EXCLUSIVE lock (blocks all reads)
- Concurrent refresh takes EXCLUSIVE lock (allows reads but not writes)
- Only one refresh at a time per matview
- Advisory lock pattern (`pg_try_advisory_lock(hash)`) is the recommended approach for application-level mutual exclusion during refresh
- Supabase has no built-in matview refresh mechanism; users roll their own

### 4. Rewrote Stage 4 checklist with corrections

Key changes from previous version:
1. **Joined-table RLS already works** — removed "harden canSeeRecord" item, replaced with integration test proof and documentation tasks
2. **Dropped matview registry FK to schedules** — over-coupling; schedules reference matviews by name in payload (same pattern as `webhook_delivery_prune` handler)
3. **Dropped `[matviews]` config section** — refresh uses existing jobs subsystem for scheduling
4. **Added migration number**: `025_ayb_matview_refreshes.sql`
5. **Added `CONCURRENTLY` prerequisites check** — must verify UNIQUE index exists before attempting concurrent refresh
6. **Added advisory lock pattern** — `pg_try_advisory_lock(hashtext(schema || '.' || view))` for mutual exclusion
7. **Added matview existence validation** — schema cache already tracks `Kind == "materialized_view"`
8. **Documented delete-event semantics** — pass-through is intentional (row is gone, can't verify RLS)
9. **Clarified manual vs scheduled refresh** — manual is synchronous, scheduled goes through job queue; both update registry metadata

### 5. Updated input file

Added Stage 4 checklist review note to `_dev/SIGIL_NINE_FEATURE_IMPLEMENTATION_CHECKLIST.md` with summary of all corrections.

## What's next

1. Start Stage 4 implementation using the corrected checklist
2. Begin with Discovery & Design: read requirements, audit code paths, record ADR
3. Then TDD: write failing tests for matview identifier validation and SQL generation, then implement `internal/matview/` package
4. Write integration tests for joined-table RLS (proving existing behavior is correct, no code changes)

## Files modified

- `.mike/SIGIL_NINE_FEATURE_IMPLEMENTATION_CHECKLIST-96c8e1/checklists/stage_04_checklist.md` — rewritten with corrections
- `_dev/SIGIL_NINE_FEATURE_IMPLEMENTATION_CHECKLIST.md` — added Stage 4 review note, updated Stage 4 description

## Key technical findings for next implementer

1. **`canSeeRecord` is correct as-is** — do NOT change it for joined-table RLS. Write integration tests proving it works with `EXISTS (SELECT 1 FROM memberships ...)` RLS policies.
2. **Delete events intentionally bypass RLS** — the row is gone, so `SELECT 1 FROM table WHERE pk = $val` can't work. Document this as intentional behavior.
3. **Schema cache tracks matviews** — `schema.Table.Kind == "materialized_view"` from `relkind='m'`. Use this to validate matview existence at registration and refresh time.
4. **Advisory locks for refresh** — use `pg_try_advisory_lock(hashtext('schema.view'))` not transactional locks. Advisory locks don't hold a transaction open during the potentially long refresh.
5. **CONCURRENTLY check** — query `pg_indexes` or `pg_index` for the matview to detect whether a UNIQUE index exists before attempting concurrent refresh. Return a clear error if missing, don't let Postgres error bubble up.
